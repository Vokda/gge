// class
[% i = 0 %]
[% FOREACH key IN modules.keys %]
[%-
	module = modules.$key
	class_name = modules.$key.class_name
	module_enum = modules.$key.gge_module_name 
-%]
[%- IF i == 0 -%]
if(class_name == "[% class_name %]")
[%- ELSE -%]
else if(class_name == "[% class_name %]")
[%- END %]
{
	module_type = [% module_enum %];
	m = moduler[module_type];
}
[% i = i + 1 -%]
[% END %]

// member function
[% i = 0 %]
[% FOR key IN modules.keys %]
[%-
	module = modules.$key
	class_name = modules.$key.class_name
	module_enum = modules.$key.gge_module_name 
	command = modules.$key.make_commands
-%]
[%- FOR com_key IN command.keys -%]
[%- 
	fn_name = command.$com_key
	fn_arg_type = command.$com_key.parameters_types.0
-%]
[%-IF i > 0 -%]else[%- END -%] if(function_name == "[% com_key %]")
{
	arg_type = [%- IF fn_arg_type -%] [% fn_arg_type %] [%- ELSE -%] NONE [%- END -%];
	arg = [% IF fn_arg_type %] [% fn_arg_type %] [%- ELSE -%] nullptr [%- END -%];
}
	[% i = i + 1 -%]
	[%- END -%]
[% END %]

switch(module_type)
{
	[% FOR key IN modules.keys %]
	[%-
		module = modules.$key
		class_name = modules.$key.class_name
		module_enum = modules.$key.gge_module_name 
		commands = modules.$key.commands
	%]
	case [% module_enum %]:
		[% FOR cmd IN commands.make_commands.keys %]
		_commands.push_back(
				make_shared<[% class_name %]>
					(module, arg, [% class_name -%]::[%- cmd %])
				);
		[% END %]
		break;
	[% END %]
	default:
	{
		std::string s = "module_type " + GGE_module::get_module_name(module_type) + " not recognized!";
		throw invalid_argument(s);
	}
}
